{"version":3,"sources":["../../../../src/lib/debounce/debounce.ts"],"names":["result"],"mappings":"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","file":"debounce.mjs","sourcesContent":["/**\n * lodash (Custom Build) https://lodash.com/\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors https://jquery.org/\n * Released under MIT license https://lodash.com/license\n * Based on Underscore.js 1.8.3 http://underscorejs.org/LICENSE\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\nexport interface DebounceSettings {\n\t/**\n\t * The number of milliseconds to delay.\n\t * @default 0\n\t */\n\twait?: number;\n\n\t/**\n\t * The maximum time `func` is allowed to be delayed before it's invoked\n\t * @default null\n\t */\n\tmaxWait?: number | null;\n}\n\nexport interface DebouncedFunc<FnArgumentsType extends any[], FnReturnType> {\n\t/**\n\t * Call the original function, but applying the debounce rules.\n\t *\n\t * If the debounced function can be run immediately, this calls it and returns its return\n\t * value.\n\t *\n\t * Otherwise, it returns the return value of the last invocation, or undefined if the debounced\n\t * function was not invoked yet.\n\t */\n\t(...args: FnArgumentsType): FnReturnType | undefined;\n\n\t/**\n\t * Throw away any pending invocation of the debounced function.\n\t */\n\tcancel(): void;\n\n\t/**\n\t * If there is a pending invocation of the debounced function, invoke it immediately and return\n\t * its return value.\n\t *\n\t * Otherwise, return the value from the last invocation, or undefined if the debounced function\n\t * was never invoked.\n\t */\n\tflush(): FnReturnType | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since\n * the last time the debounced function was invoked. The debounced function comes with a cancel method to\n * cancel delayed invocations and a flush method to immediately invoke them. Provide an options object to\n * indicate that func should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent\n * calls to the debounced function return the result of the last func invocation.\n *\n * Note: If leading and trailing options are true, func is invoked on the trailing edge of the timeout only\n * if the the debounced function is invoked more than once during the wait timeout.\n *\n * See David Corbachoâ€™s article for details over the differences between _.debounce and _.throttle.\n *\n * @param func The function to debounce.\n * @param options The options object.\n * @return Returns the new debounced function.\n */\nexport function debounce<FnArgumentsType extends any[], FnReturnType>(\n\tfunc: (...args: FnArgumentsType) => FnReturnType,\n\toptions: DebounceSettings = {}\n): DebouncedFunc<FnArgumentsType, FnReturnType> {\n\tlet lastArgs: FnArgumentsType | undefined;\n\tlet result: FnReturnType | undefined;\n\tlet timerId: NodeJS.Timeout | undefined;\n\tlet lastCallTime: number | undefined;\n\tlet lastInvokeTime = 0;\n\n\tconst wait = options.wait ?? 0;\n\tconst maxWait = typeof options.maxWait === 'number' ? Math.max(options.maxWait, wait) : null;\n\n\tfunction invokeFunc(time: number) {\n\t\tconst args = lastArgs;\n\n\t\tlastArgs = undefined;\n\t\tlastInvokeTime = time;\n\t\tresult = func(...args!);\n\t\treturn result;\n\t}\n\n\tfunction leadingEdge(time: number) {\n\t\t// Reset any `maxWait` timer.\n\t\tlastInvokeTime = time;\n\t\t// Start the timer for the trailing edge.\n\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t// Invoke the leading edge.\n\t\treturn result;\n\t}\n\n\tfunction remainingWait(time: number) {\n\t\tconst timeSinceLastCall = time - lastCallTime!;\n\t\tconst timeSinceLastInvoke = time - lastInvokeTime;\n\t\tconst result = wait - timeSinceLastCall;\n\n\t\treturn maxWait === null ? result : Math.min(result, maxWait - timeSinceLastInvoke);\n\t}\n\n\tfunction shouldInvoke(time: number) {\n\t\tconst timeSinceLastCall = time - lastCallTime!;\n\t\tconst timeSinceLastInvoke = time - lastInvokeTime;\n\n\t\t// Either this is the first call, activity has stopped and we're at the\n\t\t// trailing edge, the system time has gone backwards and we're treating\n\t\t// it as the trailing edge, or we've hit the `maxWait` limit.\n\t\treturn (\n\t\t\tlastCallTime === undefined || //\n\t\t\ttimeSinceLastCall >= wait ||\n\t\t\ttimeSinceLastCall < 0 ||\n\t\t\t(maxWait !== null && timeSinceLastInvoke >= maxWait)\n\t\t);\n\t}\n\n\tfunction timerExpired() {\n\t\tconst time = Date.now();\n\t\tif (shouldInvoke(time)) {\n\t\t\ttrailingEdge(time);\n\t\t\treturn;\n\t\t}\n\t\t// Restart the timer.\n\t\ttimerId = setTimeout(timerExpired, remainingWait(time));\n\t}\n\n\tfunction trailingEdge(time: number) {\n\t\ttimerId = undefined;\n\t\treturn invokeFunc(time);\n\t}\n\n\tfunction cancel() {\n\t\tif (timerId !== undefined) {\n\t\t\tclearTimeout(timerId);\n\t\t}\n\n\t\tlastInvokeTime = 0;\n\t\tlastArgs = undefined;\n\t\tlastCallTime = undefined;\n\t\ttimerId = undefined;\n\t}\n\n\tfunction flush() {\n\t\treturn timerId === undefined ? result : trailingEdge(Date.now());\n\t}\n\n\tfunction debounced(...args: FnArgumentsType) {\n\t\tconst time = Date.now();\n\t\tconst isInvoking = shouldInvoke(time);\n\n\t\tlastArgs = args;\n\t\tlastCallTime = time;\n\n\t\tif (isInvoking) {\n\t\t\tif (timerId === undefined) {\n\t\t\t\treturn leadingEdge(lastCallTime);\n\t\t\t}\n\t\t\tif (maxWait !== null) {\n\t\t\t\t// Handle invocations in a tight loop.\n\t\t\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t\t\treturn invokeFunc(lastCallTime);\n\t\t\t}\n\t\t}\n\n\t\tif (timerId === undefined) {\n\t\t\ttimerId = setTimeout(timerExpired, wait);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tdebounced.cancel = cancel;\n\tdebounced.flush = flush;\n\n\treturn debounced;\n}\n"]}