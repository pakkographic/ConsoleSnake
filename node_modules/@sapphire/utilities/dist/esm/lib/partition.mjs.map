{"version":3,"sources":["../../../src/lib/partition.ts"],"names":[],"mappings":";;;AAWO,SAAS,SAAA,CAAa,OAAY,SAAiD,EAAA;AACzF,EAAI,IAAA,CAAC,MAAM,OAAQ,CAAA,KAAK,GAAS,MAAA,IAAI,UAAU,2BAA2B,CAAA;AAC1E,EAAA,IAAI,CAAC,UAAW,CAAA,SAAS,GAAS,MAAA,IAAI,UAAU,6DAA6D,CAAA;AAE7G,EAAA,MAAM,eAAoB,EAAC;AAC3B,EAAA,MAAM,eAAoB,EAAC;AAE3B,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,KAAA,CAAM,QAAQ,CAAK,EAAA,EAAA;AACtC,IAAA,IAAI,SAAU,CAAA,KAAA,CAAM,CAAC,CAAA,EAAG,CAAC,CAAG,EAAA;AAC3B,MAAa,YAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA;AAAA,KACpB,MAAA;AACN,MAAa,YAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA;AAAA;AAC3B;AAGD,EAAO,OAAA,CAAC,cAAc,YAAY,CAAA;AACnC;AAhBgB,MAAA,CAAA,SAAA,EAAA,WAAA,CAAA","file":"partition.mjs","sourcesContent":["import { isFunction } from './isFunction';\n\n/**\n * Partitions `array` into a tuple of two arrays,\n * where one array contains all elements that satisfies `predicate`,\n * and the other contains all elements that do not satisfy `predicate`.\n * @param array The array to partition. This array is not mutated.\n * @param predicate The predicate function to determine in which partition the item should be placed.\n * The function should return true for items that should be placed in the first partition, and false for those that should be placed in the second partition.\n * @returns A tuple of two arrays.\n */\nexport function partition<T>(array: T[], predicate: (value: T, index: number) => boolean) {\n\tif (!Array.isArray(array)) throw new TypeError('entries must be an array.');\n\tif (!isFunction(predicate)) throw new TypeError('predicate must be an function that returns a boolean value.');\n\n\tconst partitionOne: T[] = [];\n\tconst partitionTwo: T[] = [];\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tif (predicate(array[i], i)) {\n\t\t\tpartitionOne.push(array[i]);\n\t\t} else {\n\t\t\tpartitionTwo.push(array[i]);\n\t\t}\n\t}\n\n\treturn [partitionOne, partitionTwo];\n}\n"]}