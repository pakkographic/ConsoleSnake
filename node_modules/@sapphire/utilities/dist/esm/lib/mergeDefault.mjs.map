{"version":3,"sources":["../../../src/lib/mergeDefault.ts"],"names":[],"mappings":";;;;AA0CO,SAAS,YAAA,CAAqD,MAAS,UAAqC,EAAA;AAElH,EAAA,IAAI,CAAC,UAAA,EAAmB,OAAA,SAAA,CAAU,IAAI,CAAA;AAEtC,EAAA,KAAA,MAAW,CAAC,OAAS,EAAA,SAAS,KAAK,MAAO,CAAA,OAAA,CAAQ,IAAI,CAAG,EAAA;AACxD,IAAA,MAAM,wBAA2B,GAAA,OAAA,CAAQ,GAAI,CAAA,UAAA,EAAY,OAAO,CAAA;AAEhE,IAAI,IAAA,OAAO,6BAA6B,WAAa,EAAA;AACpD,MAAA,OAAA,CAAQ,GAAI,CAAA,UAAA,EAAY,OAAS,EAAA,SAAA,CAAU,SAAS,CAAC,CAAA;AAAA,KACtD,MAAA,IAAW,QAAS,CAAA,wBAAwB,CAAG,EAAA;AAC9C,MAAQ,OAAA,CAAA,GAAA,CAAI,YAAY,OAAS,EAAA,YAAA,CAAc,gCAAa,EAAC,EAAc,wBAAwB,CAAC,CAAA;AAAA;AACrG;AAGD,EAAO,OAAA,UAAA;AACR;AAfgB,MAAA,CAAA,YAAA,EAAA,cAAA,CAAA","file":"mergeDefault.mjs","sourcesContent":["import { deepClone } from './deepClone';\nimport { isObject } from './isObject';\nimport type { DeepRequired } from './types';\n\n/**\n * Deep merges 2 objects. Properties from the second parameter are applied to the first.\n * @remark `overwrites` is also mutated!\n * @remark If the value of a key in `overwrites` is `undefined` then the value of that same key in `base` is used instead!\n * @remark This is essentially `{ ...base, ...overwrites }` but recursively\n * @param base Base object\n * @param overwrites Overwrites to apply\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = {}; // will be { a: 0, b: 1 } after merge\n * mergeDefault(base, overwrites) // { a: 0, b: 1 }\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: 2, i: 3 };\n * mergeDefault(base, overwrites) // { a: 2, i: 3, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: null };\n * mergeDefault(base, overwrites) // { a: null, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: undefined };\n * mergeDefault(base, overwrites) // { a: 0, b: 1 };\n * ```\n * @example\n * ```typescript\n * const base = { a: null };\n * const overwrites = { a: { b: 5 } };\n * mergeDefault(base, overwrites) // { a: { b: 5 } };\n * ```\n */\nexport function mergeDefault<A extends object, B extends Partial<A>>(base: A, overwrites?: B): DeepRequired<A & B> {\n\t// If no overwrites are specified then deep clone the base\n\tif (!overwrites) return deepClone(base) as DeepRequired<A & B>;\n\n\tfor (const [baseKey, baseValue] of Object.entries(base)) {\n\t\tconst overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);\n\n\t\tif (typeof overwritesValueAtBaseKey === 'undefined') {\n\t\t\tReflect.set(overwrites, baseKey, deepClone(baseValue));\n\t\t} else if (isObject(overwritesValueAtBaseKey)) {\n\t\t\tReflect.set(overwrites, baseKey, mergeDefault((baseValue ?? {}) as object, overwritesValueAtBaseKey));\n\t\t}\n\t}\n\n\treturn overwrites as DeepRequired<A & B>;\n}\n"]}