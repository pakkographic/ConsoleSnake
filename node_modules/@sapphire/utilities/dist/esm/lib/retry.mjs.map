{"version":3,"sources":["../../../src/lib/retry.ts"],"names":[],"mappings":";;;AASA,eAAsB,KAAA,CAAS,IAAwB,OAA6B,EAAA;AACnF,EAAA,IAAI,OAAU,GAAA,CAAA,EAAS,MAAA,IAAI,WAAW,sCAAsC,CAAA;AAC5E,EAAI,IAAA,OAAA,KAAY,CAAG,EAAA,OAAO,EAAG,EAAA;AAE7B,EAAI,IAAA,SAAA;AACJ,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,EAAS,EAAE,CAAG,EAAA;AACjC,IAAI,IAAA;AACH,MAAA,OAAO,MAAM,EAAG,EAAA;AAAA,aACR,KAAO,EAAA;AACf,MAAY,SAAA,GAAA,KAAA;AAAA;AACb;AAGD,EAAM,MAAA,SAAA;AACP;AAdsB,MAAA,CAAA,KAAA,EAAA,OAAA,CAAA","file":"retry.mjs","sourcesContent":["import type { Awaitable } from './types';\n\n/**\n * Asynchronously calls the callback function until it either succeeds or it runs out of retries.\n * For a synchronous variant, see [retrySync](./retrySync.d.ts).\n * @param cb The function to be retried is passed in as a callback function.\n * @param retries The number of retries is also passed in as a parameter. Minimum of 0.\n * @returns The result of the callback function is returned.\n */\nexport async function retry<T>(cb: () => Awaitable<T>, retries: number): Promise<T> {\n\tif (retries < 0) throw new RangeError('Expected retries to be a number >= 0');\n\tif (retries === 0) return cb();\n\n\tlet lastError: unknown;\n\tfor (let i = 0; i < retries; ++i) {\n\t\ttry {\n\t\t\treturn await cb();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n"]}