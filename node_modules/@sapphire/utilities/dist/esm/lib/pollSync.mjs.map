{"version":3,"sources":["../../../src/lib/pollSync.ts"],"names":["_a"],"mappings":";;;AAAA,IAAA,EAAA;AAYA,IAAM,YAAA,GAAA,CACL,gBAAW,YAAX,KAAA,IAAA,GAAA,EAAA;AAAA;AAAA,EAEA,WAAA,CAAY,KAAM,EAAA,CAAE,MAAO,CAAA;AAAA,CAAA;AAarB,SAAS,QAAY,CAAA,EAAA,EAAa,WAAoC,EAAA,OAAA,GAA2B,EAAO,EAAA;AA5B/G,EAAA,IAAAA,GAAA,EAAA,EAAA,EAAA,EAAA;AA6BC,EAAA,MAAM,OAAUA,GAAAA,CAAAA,GAAAA,GAAA,OAAQ,CAAA,OAAA,KAAR,OAAAA,GAAmB,GAAA,QAAA;AACnC,EAAA,IAAI,OAAO,OAAY,KAAA,QAAA,EAAgB,MAAA,IAAI,UAAU,iCAAiC,CAAA;AACtF,EAAA,IAAI,EAAE,OAAW,IAAA,CAAA,CAAA,EAAU,MAAA,IAAI,WAAW,8CAA8C,CAAA;AAExF,EAAM,MAAA,cAAA,GAAA,CAAiB,EAAQ,GAAA,OAAA,CAAA,cAAA,KAAR,IAA0B,GAAA,EAAA,GAAA,QAAA;AACjD,EAAA,IAAI,OAAO,cAAmB,KAAA,QAAA,EAAgB,MAAA,IAAI,UAAU,wCAAwC,CAAA;AACpG,EAAA,IAAI,EAAE,cAAkB,IAAA,CAAA,CAAA,EAAU,MAAA,IAAI,WAAW,qDAAqD,CAAA;AAEtG,EAAM,MAAA,kBAAA,GAAA,CAAqB,EAAQ,GAAA,OAAA,CAAA,kBAAA,KAAR,IAA8B,GAAA,EAAA,GAAA,CAAA;AACzD,EAAA,IAAI,OAAO,kBAAuB,KAAA,QAAA,EAAgB,MAAA,IAAI,UAAU,4CAA4C,CAAA;AAC5G,EAAA,IAAI,CAAC,MAAO,CAAA,aAAA,CAAc,kBAAkB,CAAA,IAAK,qBAAqB,CAAG,EAAA;AACxE,IAAM,MAAA,IAAI,WAAW,2DAA2D,CAAA;AAAA;AAGjF,EAAM,MAAA,GAAA,GAAM,IAAK,CAAA,GAAA,EAAQ,GAAA,OAAA;AACzB,EAAA,IAAI,SAAS,EAAG,EAAA;AAChB,EAAS,KAAA,IAAA,OAAA,GAAU,GAAG,OAAU,GAAA,cAAA,IAAkB,CAAC,WAAY,CAAA,MAAM,GAAG,OAAW,EAAA,EAAA;AAClF,IAAI,IAAA,IAAA,CAAK,KAAQ,GAAA,kBAAA,GAAqB,KAAW,MAAA,IAAI,YAAa,CAAA,4BAAA,EAA8B,YAAY,CAAA;AAC5G,IAAA,IAAI,qBAAqB,CAAG,EAAA;AAC3B,MAAA,IAAI,QAAQ,OAAS,EAAA,OAAA,CAAQ,GAAI,CAAA,CAAA,QAAA,EAAW,kBAAkB,CAA4B,0BAAA,CAAA,CAAA;AAC1F,MAAA,SAAA,CAAU,kBAAkB,CAAA;AAAA;AAG7B,IAAA,MAAA,GAAS,EAAG,EAAA;AAAA;AAGb,EAAO,OAAA,MAAA;AACR;AA5BgB,MAAA,CAAA,QAAA,EAAA,UAAA,CAAA","file":"pollSync.mjs","sourcesContent":["import type { PollOptions } from './poll';\nimport { sleepSync } from './sleepSync';\n\n/** The options for the {@link pollSync} function */\nexport interface SyncPollOptions extends Omit<PollOptions, 'signal'> {\n\t/**\n\t * The amount of milliseconds before throwing an AbortError.\n\t * @default Infinite\n\t */\n\ttimeout?: number | null | undefined;\n}\n\nconst DOMException: typeof globalThis.DOMException =\n\tglobalThis.DOMException ??\n\t// DOMException was only made a global in Node v17.0.0, but this library supports Node v16.0.0 and up\n\tAbortSignal.abort().reason.constructor;\n\n/**\n * Executes a function {@link cb} and validates the result with function {@link cbCondition},\n * and repeats this until {@link cbCondition} returns `true` or the {@link timeout} is reached.\n *\n * For an asynchronous variant, see [poll](./poll.d.ts).\n * @param cb The function that should be executed.\n * @param cbCondition A function that when given the result of `fn` should return `true` if the polling should stop and should return `false` if the polling should continue.\n * @param options Options to provide further modifying behaviour.\n * @returns The result of {@link cb} as soon as {@link cbCondition} returns `true`, or an error if {@link timeout} is reached.\n * @throws If {@link timeout} is reached.\n */\nexport function pollSync<T>(cb: () => T, cbCondition: (value: T) => boolean, options: SyncPollOptions = {}): T {\n\tconst timeout = options.timeout ?? Infinity;\n\tif (typeof timeout !== 'number') throw new TypeError('Expected timeout to be a number');\n\tif (!(timeout >= 0)) throw new RangeError('Expected timeout to be a non-negative number');\n\n\tconst maximumRetries = options.maximumRetries ?? Infinity;\n\tif (typeof maximumRetries !== 'number') throw new TypeError('Expected maximumRetries to be a number');\n\tif (!(maximumRetries >= 0)) throw new RangeError('Expected maximumRetries to be a non-negative number');\n\n\tconst waitBetweenRetries = options.waitBetweenRetries ?? 0;\n\tif (typeof waitBetweenRetries !== 'number') throw new TypeError('Expected waitBetweenRetries to be a number');\n\tif (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {\n\t\tthrow new RangeError('Expected waitBetweenRetries to be a positive safe integer');\n\t}\n\n\tconst end = Date.now() + timeout;\n\tlet result = cb();\n\tfor (let retries = 0; retries < maximumRetries && !cbCondition(result); retries++) {\n\t\tif (Date.now() + waitBetweenRetries > end) throw new DOMException('This operation was aborted', 'AbortError');\n\t\tif (waitBetweenRetries > 0) {\n\t\t\tif (options.verbose) console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);\n\t\t\tsleepSync(waitBetweenRetries);\n\t\t}\n\n\t\tresult = cb();\n\t}\n\n\treturn result;\n}\n"]}