{"version":3,"sources":["../../../src/lib/poll.ts"],"names":[],"mappings":";;;AAwCA,eAAsB,IACrB,CAAA,EAAA,EACA,WACA,EAAA,OAAA,GAAuB,EACC,EAAA;AA5CzB,EAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA;AA6CC,EAAM,MAAA,MAAA,GAAA,CAAS,EAAQ,GAAA,OAAA,CAAA,MAAA,KAAR,IAAkB,GAAA,EAAA,GAAA,KAAA,CAAA;AAEjC,EAAM,MAAA,cAAA,GAAA,CAAiB,EAAQ,GAAA,OAAA,CAAA,cAAA,KAAR,IAA0B,GAAA,EAAA,GAAA,QAAA;AACjD,EAAA,IAAI,OAAO,cAAmB,KAAA,QAAA,EAAgB,MAAA,IAAI,UAAU,wCAAwC,CAAA;AACpG,EAAA,IAAI,EAAE,cAAkB,IAAA,CAAA,CAAA,EAAU,MAAA,IAAI,WAAW,qDAAqD,CAAA;AAEtG,EAAM,MAAA,kBAAA,GAAA,CAAqB,EAAQ,GAAA,OAAA,CAAA,kBAAA,KAAR,IAA8B,GAAA,EAAA,GAAA,CAAA;AACzD,EAAA,IAAI,OAAO,kBAAuB,KAAA,QAAA,EAAgB,MAAA,IAAI,UAAU,4CAA4C,CAAA;AAC5G,EAAA,IAAI,CAAC,MAAO,CAAA,aAAA,CAAc,kBAAkB,CAAA,IAAK,qBAAqB,CAAG,EAAA;AACxE,IAAM,MAAA,IAAI,WAAW,2DAA2D,CAAA;AAAA;AAGjF,EAAQ,MAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,MAAA,CAAA,cAAA,EAAA;AACR,EAAI,IAAA,MAAA,GAAS,MAAM,EAAA,CAAG,MAAM,CAAA;AAC5B,EAAS,KAAA,IAAA,OAAA,GAAU,CAAG,EAAA,OAAA,GAAU,cAAkB,IAAA,CAAE,MAAM,WAAY,CAAA,MAAA,EAAQ,MAAM,CAAA,EAAI,OAAW,EAAA,EAAA;AAClG,IAAQ,MAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,MAAA,CAAA,cAAA,EAAA;AAER,IAAA,IAAI,qBAAqB,CAAG,EAAA;AAC3B,MAAA,IAAI,QAAQ,OAAS,EAAA,OAAA,CAAQ,GAAI,CAAA,CAAA,QAAA,EAAW,kBAAkB,CAA4B,0BAAA,CAAA,CAAA;AAC1F,MAAA,MAAM,KAAM,CAAA,kBAAA,EAAoB,KAAW,CAAA,EAAA,EAAE,QAAQ,CAAA;AAAA;AAGtD,IAAS,MAAA,GAAA,MAAM,GAAG,MAAM,CAAA;AAAA;AAGzB,EAAO,OAAA,MAAA;AACR;AA/BsB,MAAA,CAAA,IAAA,EAAA,MAAA,CAAA","file":"poll.mjs","sourcesContent":["import { sleep } from './sleep';\nimport type { Awaitable } from './types';\n\n/** The options for the {@link poll} function */\nexport interface PollOptions {\n\t/**\n\t * An optional AbortSignal to abort the polling.\n\t */\n\tsignal?: AbortSignal | undefined;\n\n\t/**\n\t * The amount of attempts to try, if any.\n\t * @default Infinite\n\t */\n\tmaximumRetries?: number | null | undefined;\n\n\t/**\n\t * The amount of time to wait between each poll.\n\t * @default 0\n\t */\n\twaitBetweenRetries?: number | null | undefined;\n\n\t/**\n\t * Whether to log to the console on each polling interval, allowing the tracing of the amount of required attempts.\n\t * @default false\n\t */\n\tverbose?: boolean | undefined;\n}\n\n/**\n * Executes a function {@link cb} and validates the result with function {@link cbCondition},\n * and repeats this until {@link cbCondition} returns `true` or the {@link timeout} is reached.\n *\n * For a synchronous variant, see [pollSync](./pollSync.d.ts).\n * @param cb The function that should be executed.\n * @param cbCondition A function that when given the result of `cb` should return `true` if the polling should stop and should return `false` if the polling should continue.\n * @param options Options to provide further modifying behaviour.\n * @returns The result of {@link cb} as soon as {@link cbCondition} returns `true`, or an error if {@link timeout} is reached.\n * @throws If {@link timeout} is reached.\n */\nexport async function poll<T>(\n\tcb: (signal: AbortSignal | undefined) => Awaitable<T>,\n\tcbCondition: (value: Awaited<T>, signal: AbortSignal | undefined) => Awaitable<boolean>,\n\toptions: PollOptions = {}\n): Promise<Awaitable<T>> {\n\tconst signal = options.signal ?? undefined;\n\n\tconst maximumRetries = options.maximumRetries ?? Infinity;\n\tif (typeof maximumRetries !== 'number') throw new TypeError('Expected maximumRetries to be a number');\n\tif (!(maximumRetries >= 0)) throw new RangeError('Expected maximumRetries to be a non-negative number');\n\n\tconst waitBetweenRetries = options.waitBetweenRetries ?? 0;\n\tif (typeof waitBetweenRetries !== 'number') throw new TypeError('Expected waitBetweenRetries to be a number');\n\tif (!Number.isSafeInteger(waitBetweenRetries) || waitBetweenRetries < 0) {\n\t\tthrow new RangeError('Expected waitBetweenRetries to be a positive safe integer');\n\t}\n\n\tsignal?.throwIfAborted();\n\tlet result = await cb(signal);\n\tfor (let retries = 0; retries < maximumRetries && !(await cbCondition(result, signal)); retries++) {\n\t\tsignal?.throwIfAborted();\n\n\t\tif (waitBetweenRetries > 0) {\n\t\t\tif (options.verbose) console.log(`Waiting ${waitBetweenRetries}ms before polling again...`);\n\t\t\tawait sleep(waitBetweenRetries, undefined, { signal });\n\t\t}\n\n\t\tresult = await cb(signal);\n\t}\n\n\treturn result;\n}\n"]}