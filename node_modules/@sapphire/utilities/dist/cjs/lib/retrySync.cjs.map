{"version":3,"sources":["../../../src/lib/retrySync.ts"],"names":[],"mappings":";;;;;;AAOO,SAAS,SAAA,CAAa,IAAa,OAAoB,EAAA;AAC7D,EAAA,IAAI,OAAU,GAAA,CAAA,EAAS,MAAA,IAAI,WAAW,sCAAsC,CAAA;AAC5E,EAAI,IAAA,OAAA,KAAY,CAAG,EAAA,OAAO,EAAG,EAAA;AAE7B,EAAI,IAAA,SAAA;AACJ,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,EAAS,EAAE,CAAG,EAAA;AACjC,IAAI,IAAA;AACH,MAAA,OAAO,EAAG,EAAA;AAAA,aACF,KAAO,EAAA;AACf,MAAY,SAAA,GAAA,KAAA;AAAA;AACb;AAGD,EAAM,MAAA,SAAA;AACP;AAdgB,MAAA,CAAA,SAAA,EAAA,WAAA,CAAA","file":"retrySync.cjs","sourcesContent":["/**\n * Synchronously calls the callback function until it either succeeds or it runs out of retries.\n * For an asynchronous variant, see [retry](./retry.d.ts).\n * @param cb The function to be retried is passed in as a callback function.\n * @param retries The number of retries is also passed in as a parameter. Minimum of 0.\n * @returns The result of the callback function is returned.\n */\nexport function retrySync<T>(cb: () => T, retries: number): T {\n\tif (retries < 0) throw new RangeError('Expected retries to be a number >= 0');\n\tif (retries === 0) return cb();\n\n\tlet lastError: unknown;\n\tfor (let i = 0; i < retries; ++i) {\n\t\ttry {\n\t\t\treturn cb();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n"]}